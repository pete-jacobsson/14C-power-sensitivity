library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
library(Bchron)
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
draw_predict <- function (stan_model, other_param, value_range, mode = "median"){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It also takes on an indication if it is to use the median outcome, or a results from a random chain
###It returns a two column DF with input values and
return(stan_model)
}
prep_predict_df(posterior_68_pos)
draw_predict <- function (stan_model, other_param, value_range, mode = "median"){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It also takes on an indication if it is to use the median outcome, or a results from a random chain
###It returns a two column DF with input values and
return(stan_model)
}
prep_predict_df(posterior_68_pos)
draw_predict(posterior_68_pos)
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
library(Bchron)
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
draw_predict <- function (stan_model, other_param, value_range){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It also takes on an indication if it is to use the median outcome, or a results from a random chain
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
draw_num
}
draw_predict(posterior_68_pos)
draw_predict <- function (stan_model, other_param, value_range){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It also takes on an indication if it is to use the median outcome, or a results from a random chain
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
intercept <- model[draw_num, 1:4, 1]
offset_effect <- model[draw_num, 1:4, 2]
uncert_effect <- model[draw_num, 1:4, 3]
list(intercept, offset_effect, uncert_effect)
}
draw_predict(posterior_68_pos)
draw_predict <- function (model, other_param, value_range){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It also takes on an indication if it is to use the median outcome, or a results from a random chain
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
intercept <- model[draw_num, 1:4, 1]
offset_effect <- model[draw_num, 1:4, 2]
uncert_effect <- model[draw_num, 1:4, 3]
list(intercept, offset_effect, uncert_effect)
}
draw_predict(posterior_68_pos)
draw_predict <- function (model, other_param, value_range){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It also takes on an indication if it is to use the median outcome, or a results from a random chain
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
intercept <- model[draw_num, 1:4, 1] |>
median()
offset_effect <- model[draw_num, 1:4, 2] |>
median()
uncert_effect <- model[draw_num, 1:4, 3] |>
median()
list(intercept, offset_effect, uncert_effect)
}
draw_predict(posterior_68_pos)
draw_predict_random <- function (model, param_plotted,
value_range, other_param){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
intercept <- model[draw_num, 1:4, 1] |>
median()
offset_effect <- model[draw_num, 1:4, 2] |>
median()
uncert_effect <- model[draw_num, 1:4, 3] |>
median()
if (str_detect(param_plotted, "offset")) {
exp_term <- intercept +
value_range * offset_effect +
other_param * uncert_effect
}
exp_term
# exp_term <- intercepts +
#   offset_magnitude * offset_effects +
#   sigma_curve_uncert * uncert_effects
#
# pred_results <- 1 / (1 + exp(-exp_term))
#
# pred_results
}
draw_predict(posterior_68_pos, "offset", seq(0, 50, 1), 25)
draw_predict_random <- function (model, param_plotted,
value_range, other_param){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
intercept <- model[draw_num, 1:4, 1] |>
median()
offset_effect <- model[draw_num, 1:4, 2] |>
median()
uncert_effect <- model[draw_num, 1:4, 3] |>
median()
if (str_detect(param_plotted, "offset")) {
exp_term <- intercept +
value_range * offset_effect +
other_param * uncert_effect
}
exp_term
# exp_term <- intercepts +
#   offset_magnitude * offset_effects +
#   sigma_curve_uncert * uncert_effects
#
# pred_results <- 1 / (1 + exp(-exp_term))
#
# pred_results
}
draw_predict_random(posterior_68_pos, "offset", seq(0, 50, 1), 25)
draw_predict_random <- function (model, param_plotted,
value_range, other_param){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
intercept <- model[draw_num, 1:4, 1] |>
median()
offset_effect <- model[draw_num, 1:4, 2] |>
median()
uncert_effect <- model[draw_num, 1:4, 3] |>
median()
if (str_detect(param_plotted, "offset")) {
exp_term <- intercept +
value_range * offset_effect +
other_param * uncert_effect
} else {
exp_term <- intercept +
value_range * uncert_effect +
other_param * offset_effect
}
exp_term
# exp_term <- intercepts +
#   offset_magnitude * offset_effects +
#   sigma_curve_uncert * uncert_effects
#
# pred_results <- 1 / (1 + exp(-exp_term))
#
# pred_results
}
draw_predict_random(posterior_68_pos, "offset", seq(0, 50, 1), 25)
draw_predict_random(posterior_68_pos, "", seq(0, 50, 1), 25)
draw_predict_random <- function (model, param_plotted,
value_range, other_param){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
intercept <- model[draw_num, 1:4, 1] |>
median()
offset_effect <- model[draw_num, 1:4, 2] |>
median()
uncert_effect <- model[draw_num, 1:4, 3] |>
median()
if (str_detect(param_plotted, "offset")) {
exp_term <- intercept +
value_range * offset_effect +
other_param * uncert_effect
} else {
exp_term <- intercept +
value_range * uncert_effect +
other_param * offset_effect
}
pred_results <- 1 / (1 + exp(-exp_term))
pred_results
}
draw_predict_random(posterior_68_pos, "offset", seq(0, 50, 1), 25)
draw_predict_random(posterior_68_pos, "", seq(0, 50, 1), 25)
draw_predict_median <- function (model, param_plotted,
value_range, other_param){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It returns a two column DF with input values and
intercept <- model[1:1000, 1:4, 1] |>
median()
offset_effect <- model[1:1000, 1:4, 2] |>
median()
uncert_effect <- model[1:1000, 1:4, 3] |>
median()
if (str_detect(param_plotted, "offset")) {
exp_term <- intercept +
value_range * offset_effect +
other_param * uncert_effect
} else {
exp_term <- intercept +
value_range * uncert_effect +
other_param * offset_effect
}
pred_results <- 1 / (1 + exp(-exp_term))
pred_results
}
draw_predict_median(posterior_68_pos, "offset", seq(0, 50, 1), 25)
draw_predict_median(posterior_68_pos, "", seq(0, 50, 1), 25)
draw_predict_random <- function (model, param_plotted,
value_range, other_param){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
intercept <- model[draw_num, 1:4, 1] |>
median()
offset_effect <- model[draw_num, 1:4, 2] |>
median()
uncert_effect <- model[draw_num, 1:4, 3] |>
median()
if (str_detect(param_plotted, "offset")) {
exp_term <- intercept +
value_range * offset_effect +
other_param * uncert_effect
} else {
exp_term <- intercept +
value_range * uncert_effect +
other_param * offset_effect
}
pred_results <- 1 / (1 + exp(-exp_term))
pred_results <- data.frame(value_range, pred_results)
pred_results
}
draw_predict_random(posterior_68_pos, "offset", seq(0, 50, 1), 25)
draw_predict_random(posterior_68_pos, "", seq(0, 50, 1), 25)
draw_predict_median <- function (model, param_plotted,
value_range, other_param){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It returns a two column DF with input values and
intercept <- model[1:1000, 1:4, 1] |>
median()
offset_effect <- model[1:1000, 1:4, 2] |>
median()
uncert_effect <- model[1:1000, 1:4, 3] |>
median()
if (str_detect(param_plotted, "offset")) {
exp_term <- intercept +
value_range * offset_effect +
other_param * uncert_effect
} else {
exp_term <- intercept +
value_range * uncert_effect +
other_param * offset_effect
}
pred_results <- 1 / (1 + exp(-exp_term))
pred_results <-  data.frame(value_range, pred_results)
pred_results
}
draw_predict_median(posterior_68_pos, "offset", seq(0, 50, 1), 25)
draw_predict_median(posterior_68_pos, "", seq(0, 50, 1), 25)
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
library(Bchron)
draw_predict_random <- function (model, param_plotted,
value_range, other_param){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It returns a two column DF with input values and
draw_num <- sample(seq(1:1000), 1)
intercept <- model[draw_num, 1:4, 1] |>
median()
offset_effect <- model[draw_num, 1:4, 2] |>
median()
uncert_effect <- model[draw_num, 1:4, 3] |>
median()
if (str_detect(param_plotted, "offset")) {
exp_term <- intercept +
value_range * offset_effect +
other_param * uncert_effect
} else {
exp_term <- intercept +
value_range * uncert_effect +
other_param * offset_effect
}
pred_results <- 1 / (1 + exp(-exp_term))
pred_results <- data.frame(value_range, pred_results)
pred_results
}
draw_predict_random(posterior_68_pos, "offset", seq(0, 50, 1), 25)
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
draw_predict_random(posterior_68_pos, "offset", seq(0, 50, 1), 25)
draw_predict_random(posterior_68_pos, "", seq(0, 50, 1), 25)
draw_predict_median <- function (model, param_plotted,
value_range, other_param){
###This function draws a single prediction from the STAN results
###It takes on the link to the STAN model, the value of the other parameter and a rangle of values for which to generate predictions.
###It returns a two column DF with input values and
intercept <- model[1:1000, 1:4, 1] |>
median()
offset_effect <- model[1:1000, 1:4, 2] |>
median()
uncert_effect <- model[1:1000, 1:4, 3] |>
median()
if (str_detect(param_plotted, "offset")) {
exp_term <- intercept +
value_range * offset_effect +
other_param * uncert_effect
} else {
exp_term <- intercept +
value_range * uncert_effect +
other_param * offset_effect
}
pred_results <- 1 / (1 + exp(-exp_term))
pred_results <-  data.frame(value_range, pred_results)
pred_results
}
draw_predict_median(posterior_68_pos, "offset", seq(0, 50, 1), 25)
draw_predict_median(posterior_68_pos, "", seq(0, 50, 1), 25)
plot_simulation_results_osc <- function(range_to_plot, hpd_area, variable,
rounding, xlab) {
##This function plots the simulation results for the purposes of the results graphing
single_cals_curve_uncert_mod <- read_csv("single_cals_w_curve_uncert.csv") %>%
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
single_cals_curve_uncert_mod %>%
rename(variable_to_plot = variable, hpd_to_plot = hpd_area) %>%
filter(variable_to_plot >= range_to_plot[1] &
variable_to_plot <= range_to_plot) %>%
mutate(
variable_to_plot = plyr::round_any(variable_to_plot, rounding)
) %>%
select(variable_to_plot, hpd_to_plot) %>%
group_by(variable_to_plot) %>%
summarize(
ratio_accurate = mean(hpd_to_plot)
) %>%
ggplot(aes(x = variable_to_plot, y = ratio_accurate)) +
geom_bar(stat = 'identity', fill = "steelblue") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", linewidth = 0.5),
text = element_text(family = "Corbel")#,
#axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 9)
) +
labs(
y = "Ratio accurate",
x = xlab
)
}
### Now plot over simulations
plot_simulation_results_osc(c(0, 50), "68", "offset_magnitude", 1, "Offset magnitude")
### Now plot over simulations
plot_simulation_results_osc(c(0, 50), "acc_68", "offset_magnitude", 1,
"Offset magnitude")
### Now plot over simulations
plot_simulation_results_osc(c(0, 50), "accuracy_68", "offset_magnitude", 1,
"Offset magnitude")
median_predicts <- draw_predict_median(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(1 = "offset_magnitude", 2 = "Ratio accurate")
median_predicts <- draw_predict_median(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(offset_magnitude = 1, ratio_accurate = 2)
p + geom_line(data = median_predicts)
p <- plot_simulation_results_osc(c(0, 50), "accuracy_68", "offset_magnitude", 1,
"Offset magnitude")
p + geom_line(data = median_predicts)
p <- plot_simulation_results_osc(range_to_plot = c(0, 50), hpd_area = "accuracy_68",
variable = "offset_magnitude", rounding = 2,
xlab = "Offset magnitude")
p + geom_line(data = median_predicts)
plot_model_predictions_ocs <- function(offset_dir, hpd_area, model_name, variable,
range, rounding, xlab) {
## This function wraps predict_model_results and plot_simulation_results and plots prediction over simulation.
## parameters and assumptions as per underpinning functions.
plot <- plot_simulation_results_osc(range_to_plot = range, hpd_area = hpd_area,
variable = variable, rounding = rounding,
xlab = xlab)
hpd_for_predict = str_extract(hpd_area, "\\d{2}") ## predict_model_results only takes two-digit numbers as input here (for filtering) - this extracts from HPD area above
predicts_tab <- predict_model_results_osc(offset_dir = offset_dir,
hpd_area = hpd_for_predict,
model_name = model_name,
variable = variable,
variable_range = seq(range[1],
range[2]))
predicts_tab <- predicts_tab %>%
rename("variable_to_plot" = variable, ratio_accurate = 1) ##Dovetail the variable names for the plot at the iteration where interactions start getting explored
plot <- plot +
geom_line(data = predicts_tab)
plot
}
plot_simulation_results_osc(range_to_plot = c(0, 50), hpd_area = "accuracy_68",
variable = "offset_magnitude", rounding = 2,
xlab = "Offset magnitude")
p <- plot_simulation_results_osc(range_to_plot = c(0, 50), hpd_area = "accuracy_68",
variable = "offset_magnitude", rounding = 2,
xlab = "Offset magnitude")
p
median_predicts <- draw_predict_median(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p + geom_line(data = median_predicts)
### Now plot over simulations
p <- plot_simulation_results_osc(range_to_plot = c(0, 50), hpd_area = "accuracy_68",
variable = "offset_magnitude", rounding = 2,
xlab = "Offset magnitude")
for (i in 1:20) {
sample_predict <- draw_predict_random(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p <- p + geom_line(data = sample_predict, linewidth = 0.1, linetype = 2)
}
median_predicts <- draw_predict_median(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p + geom_line(data = median_predicts)
### Now plot over simulations
p <- plot_simulation_results_osc(range_to_plot = c(0, 50), hpd_area = "accuracy_68",
variable = "offset_magnitude", rounding = 2,
xlab = "Offset magnitude")
for (i in 1:20) {
sample_predict <- draw_predict_random(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p <- p + geom_line(data = sample_predict, linewidth = 0.1, linetype = 1)
}
median_predicts <- draw_predict_median(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p + geom_line(data = median_predicts)
single_cals_w_curve_uncert <- read_csv("single_cals_w_curve_uncert.csv") |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
### Now plot over simulations
single_cals_w_curve_uncert <- read_csv("single_cals_w_curve_uncert.csv") |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
p <- plot_simulation_results_osc(range_to_plot = c(0, 50), hpd_area = "accuracy_68",
variable = "offset_magnitude", rounding = 2,
xlab = "Offset magnitude")
for (i in 1:20) {
sigma_curve_uncert <- sample(single_cals_w_curve_uncert$sigma_curve_uncert, 1)
sample_predict <- draw_predict_random(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p <- p + geom_line(data = sample_predict, linewidth = 0.1, linetype = 1)
}
median_predicts <- draw_predict_median(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p + geom_line(data = median_predicts)
### Now plot over simulations
single_cals_w_curve_uncert <- read_csv("single_cals_w_curve_uncert.csv") |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
p <- plot_simulation_results_osc(range_to_plot = c(0, 50), hpd_area = "accuracy_68",
variable = "offset_magnitude", rounding = 2,
xlab = "Offset magnitude")
for (i in 1:20) {
sigma_curve_uncert <- sample(single_cals_w_curve_uncert$sigma_curve_uncert, 1)
sample_predict <- draw_predict_random(posterior_68_pos, "offset",
seq(0, 50, 1), sigma_curve_uncert) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p <- p + geom_line(data = sample_predict, linewidth = 0.1, linetype = 1)
}
median_predicts <- draw_predict_median(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p + geom_line(data = median_predicts)
### Now plot over simulations
single_cals_w_curve_uncert <- read_csv("single_cals_w_curve_uncert.csv") |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
p <- plot_simulation_results_osc(range_to_plot = c(0, 50), hpd_area = "accuracy_68",
variable = "offset_magnitude", rounding = 2,
xlab = "Offset magnitude")
for (i in 1:50) {
sigma_curve_uncert <- sample(single_cals_w_curve_uncert$sigma_curve_uncert, 1)
sample_predict <- draw_predict_random(posterior_68_pos, "offset",
seq(0, 50, 1), sigma_curve_uncert) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p <- p + geom_line(data = sample_predict, linewidth = 0.1, linetype = 1)
}
median_predicts <- draw_predict_median(posterior_68_pos, "offset",
seq(0, 50, 1), 25) |>
rename(variable_to_plot = 1, ratio_accurate = 2)
p + geom_line(data = median_predicts)
