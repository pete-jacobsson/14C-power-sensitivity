offset_curve_sigma_comb_interact_params %>%
mutate(
is_pos = if_else(is_pos, "pos_offset", "neg_offset"),
hpd_area = if_else(str_detect(model, "68"), "68.2% HPD", "95.4% HPD")
) %>%
ggplot(aes(x = is_pos, y = estimate)) +
geom_hline(yintercept = 0, color = "grey80") +
geom_point(stat = "identity") +
geom_linerange(aes(ymin = estimate - 2*std.error, ymax = estimate + 2*std.error)) +
facet_grid(rows = vars(term), cols = vars(hpd_area), scales = "free") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", size = 0.5),
#legend.position = "none",
strip.background = element_rect(
color="white", fill="white"
),
text = element_text(family = "Corbel"),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 9)
) +
labs(
subtitle = "68.2% HPD"
)
offset_curve_sigma_comb_params %>%
filter(str_detect(term, "Interce")) %>%
select(is_pos, model, estimate) %>%
mutate(acc_zero = 1 / (1 + exp(- estimate)))
offset_curve_sigma_comb_interact_params %>%
filter(str_detect(term, "Interce")) %>%
select(is_pos, model, estimate) %>%
mutate(acc_zero = 1 / (1 + exp(- estimate)))
offset_curve_sigma_comb_params %>%
filter(str_detect(term, "Interce")) %>%
select(is_pos, model, estimate, std.error) %>%
mutate(
acc_zero = 1 / (1 + exp(- estimate)),
acc_zero_min = 1 / (1 + exp(- (estimate - 2 * std.error))),
acc_zero_max = 1 / (1 + exp(- (estimate + 2 * std.error))),
)
predict_model_results_osc <- function(offset_dir, hpd_area, model_name,
variable, variable_range) {
##Function to simplify prediction generation
##Takes on offset_dir and hpd_area, which simplify the results table,
##Takes on variable name as string and variable range as a sequence
##Assumes offset dir, hpd_area, and variable name provided are all correct
offset_curve_sigma_os <- readRDS("single_cals_curve_uncert_regr.rds") %>%
filter(str_detect(model, model_name)) %>%
mutate(is_pos = if_else(is_pos, "positive", "negative")) %>% ## Change type for filtering
filter(str_detect(is_pos, offset_dir) & str_detect(model, hpd_area))
predicted_results <- make_predictions(offset_curve_sigma_os$model_results[[1]],
pred = variable,
pred.values = variable_range)
predicted_results
}
#### Oooohhh... it works without modification... Thank you past me!
## Function tests
predict_model_results_osc(offset_dir = "pos", hpd_area = "68",
model_name = "comb_acc",
variable = "offset_magnitude",
variable_range = seq(0, 50))
predict_model_results_osc(offset_dir = "neg", hpd_area = "95",
model_name = "comb_acc",
variable = "sigma_curve_uncert",
variable_range = seq(10, 35))
plot_model_predictions_ocs <- function(offset_dir, hpd_area, model_name, variable,
range, rounding, xlab) {
## This function wraps predict_model_results and plot_simulation_results and plots prediction over simulation.
## parameters and assumptions as per underpinning functions.
plot <- plot_simulation_results_osc(range_to_plot = range, hpd_area = hpd_area,
variable = variable, rounding = rounding,
xlab = xlab)
hpd_for_predict = str_extract(hpd_area, "\\d{2}") ## predict_model_results only takes two-digit numbers as input here (for filtering) - this extracts from HPD area above
predicts_tab <- predict_model_results_osc(offset_dir = offset_dir,
hpd_area = hpd_for_predict,
model_name = model_name,
variable = variable,
variable_range = seq(range[1],
range[2]))
predicts_tab <- predicts_tab %>%
rename("variable_to_plot" = variable, ratio_accurate = 1) ##Dovetail the variable names for the plot at the iteration where interactions start getting explored
plot <- plot +
geom_line(data = predicts_tab)
plot
}
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
model_name = "comb_acc",
variable = "offset_magnitude",
range = c(0, 50), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs(offset_dir = "neg", hpd_area = "accuracy_68",
model_name = "comb_acc",
variable = "offset_magnitude",
range = c(-50, 0), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_95",
model_name = "comb_acc",
variable = "offset_magnitude",
range = c(0, 50), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs(offset_dir = "neg", hpd_area = "accuracy_95",
model_name = "comb_acc",
variable = "offset_magnitude",
range = c(-50, 0), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
variable = "sigma_curve_uncert",
model_name = "comb_acc",
range = c(10, 40), rounding = 2,
xlab = "Measurement and curve error")
plot_model_predictions_ocs(offset_dir = "neg", hpd_area = "accuracy_68",
variable = "sigma_curve_uncert",
model_name = "comb_acc",
range = c(10, 40), rounding = 2,
xlab = "Measurement and curve error")
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_95",
variable = "sigma_curve_uncert",
model_name = "comb_acc",
range = c(10, 40), rounding = 2,
xlab = "Measurement and curve error")
plot_model_predictions_ocs(offset_dir = "neg", hpd_area = "accuracy_95",
variable = "sigma_curve_uncert",
model_name = "comb_acc",
range = c(10, 40), rounding = 2,
xlab = "Measurement and curve error")
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
stan_offset_sigma_curve_comb_acc95 <- function(singles_data) {
stan_glm(accuracy_95 ~ offset_magnitude + sigma_curve_uncert,
data = singles_data, family = binomial(link = 'logit'))
}
##Read and nest the data
single_cals_w_curve_uncert <- read_csv("single_cals_w_curve_uncert.csv")
##Nesting
single_cals_curve_uncert_nest <- single_cals_w_curve_uncert %>%
mutate(is_pos = if_else(offset_magnitude >= 0, TRUE, FALSE)) %>%
select(curve_uncert, measurement_error, offset_magnitude, accuracy_68,
accuracy_95, is_pos) %>%
group_by(is_pos) %>%
nest()
###Test the STAN functions
single_cals_curve_uncert_nest %>%
filter(is_pos)
###Test the STAN functions
test <- single_cals_curve_uncert_nest %>%
filter(is_pos) %>%
stan_offset_sigma_curve_comb_acc95()
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
install.packages("rstanarm")
install.packages("lme4")
install.packages("nloptr")
install.packages("rstanarm")
library(rstanarm)
###Test the STAN functions
test <- single_cals_curve_uncert_nest %>%
filter(is_pos) %>%
stan_offset_sigma_curve_comb_acc95()
###Test the STAN functions
test <- single_cals_curve_uncert_nest %>%
filter(is_pos) %>%
stan_offset_sigma_curve_comb_acc95(singles_data = data)
###Test the STAN functions
test <- single_cals_w_curve_uncert %>%
filter(is_pos) %>%
stan_glm(accuracy_95 ~ offset_magnitude + sigma_curve_uncert,
family = binomial(link = 'logit'))
###Test the STAN functions
test <- single_cals_w_curve_uncert %>%
filter(offset_magnitude > 0) %>%
stan_glm(accuracy_95 ~ offset_magnitude + sigma_curve_uncert,
family = binomial(link = 'logit'))
###Test the STAN functions
test_df <- single_cals_w_curve_uncert %>%
filter(offset_magnitude > 0)
test_result <- stan_glm(accuracy_95 ~ offset_magnitude + sigma_curve_uncert,
data = test_df, family = binomial(link = 'logit'))
summary(test_result)
test_result <- stan_glm(accuracy_68 ~ offset_magnitude + sigma_curve_uncert,
data = test_df, family = binomial(link = 'logit'))
summary(test_result)
test_result <- stan_glm(accuracy_95 ~ offset_magnitude + sigma_curve_uncert,
data = test_df, family = binomial(link = 'logit'))
summary(test_result)
##Read and nest the data
single_cals_w_curve_uncert <- read_csv("single_cals_w_curve_uncert.csv")
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
##Read and nest the data
single_cals_w_curve_uncert <- read_csv("single_cals_w_curve_uncert.csv")
##Nesting
single_cals_curve_uncert_nest <- single_cals_w_curve_uncert %>%
mutate(is_pos = if_else(offset_magnitude >= 0, TRUE, FALSE)) %>%
select(curve_uncert, measurement_error, offset_magnitude, accuracy_68,
accuracy_95, is_pos) %>%
group_by(is_pos) %>%
nest()
###Test the STAN functions
test_df <- single_cals_w_curve_uncert %>%
filter(offset_magnitude > 0)
test_result <- stan_glm(accuracy_95 ~ offset_magnitude + sigma_curve_uncert,
data = test_df, family = binomial(link = 'logit'))
summary(test_result)
single_cals_curve_for_stan <- single_cals_w_curve_uncert %>%
pivot_longer(c(accuracy_68, accuracy_95))
View(single_cals_curve_for_stan)
single_cals_curve_for_stan <- single_cals_w_curve_uncert %>%
pivot_longer(c(accuracy_68, accuracy_95),
names_to = "hpd_area", values_to = "accuracy") %>%
select(curve_uncert, measurement_error, offset_magnitude,
hpd_area, accuracy) %>%
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
single_cals_curve_for_stan <- single_cals_w_curve_uncert %>%
pivot_longer(c(accuracy_68, accuracy_95),
names_to = "hpd_area", values_to = "accuracy") %>%
select(curve_uncert, measurement_error, offset_magnitude,
hpd_area, accuracy) %>%
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "68") & is_pos)
###Test the STAN functions
stan_results <- list()
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "68") & offset_magnitude > 0)
stan_offset_curve_sigma_comb_68_pos <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_results <- append(stan_results, stan_offset_curve_sigma_comb_68_pos)
###Test the STAN functions - yes an ugly way to do it, but too few to justify setting up a nicer loop.
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "68") & offset_magnitude > 0)
stan_offset_curve_sigma_comb_68_pos <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "95") & offset_magnitude > 0)
stan_offset_curve_sigma_comb_95_pos <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "68") & offset_magnitude < 0)
stan_offset_curve_sigma_comb_68_neg <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "95") & offset_magnitude < 0)
stan_offset_curve_sigma_comb_95_neg <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_offset_curve_sigma_comb <- list(
stan_offset_curve_sigma_comb_68_pos,
stan_offset_curve_sigma_comb_68_neg,
stan_offset_curve_sigma_comb_95_pos,
stan_offset_curve_sigma_comb_95_neg
)
##Lets not keep re-running the models if we don't need to :)
write_rds(stan_offset_curve_sigma_comb, "stan_offset_curve_sigma_comb.rds")
summary(stan_offset_curve_sigma_comb[[1]])
summary(stan_offset_curve_sigma_comb[[2]]) ##68neg
summary(stan_offset_curve_sigma_comb[[3]]) ##95pos
summary(stan_offset_curve_sigma_comb[[4]]) ##95neg
help("summary.stanreg")
installed.packages("bayesplot")
instal.packages("bayesplot")
install.packages("bayesplot")
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
##Lets not keep re-running the models if we don't need to :)
write_rds(stan_offset_curve_sigma_comb, "stan_offset_curve_sigma_comb.rds")
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterios_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
dim(posterios_68_pos)
dimnames(posterios_68_pos)
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
color_scheme_set("blue")
mcmc_hist(posterior_68_pos, pars = c("offset_magnitude", "(Intercept)",
"sigma_curve_uncert"))
color_scheme_set("blue")
mcmc_hist(posterior_68_pos, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
mcmc_hist(posterior_68_neg, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
color_scheme_set("blue")
mcmc_hist(posterior_68_pos, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
mcmc_hist(posterior_68_neg, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
mcmc_hist(posterior_95_pos, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
mcmc_hist(posterior_95_neg, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
mcmc_parcoord(posterior_68_neg)
mcmc_parcoord(posterior_68_neg)
mcmc_parcoord(posterior_68_pos)
mcmc_parcoord(posterior_95_neg)
mcmc_parcoord(posterior_95_pos)
mcmc_pairs(posterior_68_pos)
mcmc_pairs(posterior_68_pos)
mcmc_pairs(posterior_68_neg)
mcmc_pairs(posterior_95_pos)
mcmc_pairs(posterior_95_neg)
mcmc_trace(posterior_68_pos)
mcmc_trace(posterior_68_neg)
mcmc_trace(posterior_95_pos)
mcmc_trace(posterior_95_neg)
mcmc_rhat(posterior_68_pos)
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
dimnames(posterior_68_pos)
dimnames(posterior_68_pos[1])
dimnames(posterior_68_pos[[1]])
coef(posterior_68_pos)[1]
posterior_68_pos[1]
posterior_68_pos[1:1000]
posterior_68_pos[1:1000, 1:4, 1]
posterior_68_pos[1:1000, 1, 1:3]
posterior_68_pos[1:1000, 1, 1]
offset_effects <- posterior_68_pos[1:1000, 1, 2]
offset_effects <- posterior_68_pos[1:1000, 1, 2]
intercepts <- posterior_68_pos[1:1000, 1, 1]
uncert_effects <- posterior_68_pos[1:1000, 1, 3]
pred_results <- intercepts + 20 * offset_effects + 20 * uncert_effects
exp_term <- intercepts + 20 * offset_effects + 20 * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
hist(pred_results)
exists("potato")
exists(stan_offset_curve_sigma_comb)
exists("stan_offset_curve_sigma_comb")
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir = "pos" & hpd_area = "68") {
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
model
}
predict_singles_accuracy("pos", "68")
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
intercepts
}
predict_singles_accuracy("pos", "68")
predict_singles_accuracy("pos", "95")
predict_singles_accuracy("neg", "95")
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
exp_term <- intercepts +
offset_magnitude * offset_effects +
sigma_curve_uncert * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
}
predict_singles_accuracy("neg", "95", 0, 40)
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
exp_term <- intercepts +
offset_magnitude * offset_effects +
sigma_curve_uncert * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
pred_results
}
predict_singles_accuracy("neg", "95", 0, 40)
predict_singles_accuracy("neg", "95", -40, 40)
predict_singles_accuracy("neg", "95", -40, 10)
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma, curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
## Get the chain results out
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
##Do the maths
sigma_curve_uncert <- sqrt((sigma ^ 2) + (curve_uncert ^ 2))
exp_term <- intercepts +
offset_magnitude * offset_effects +
sigma_curve_uncert * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
pred_results
}
predict_singles_accuracy("neg", "95", -40, 10, 30)
predict_singles_accuracy("pos", "68", 40, 10, 30)
predict_singles_accuracy("neg", "68", -40, 10, 30)
predict_singles_accuracy("pos", "95", 40, 10, 30)
predict_singles_accuracy("neg", "95", -40, 10, 30)
