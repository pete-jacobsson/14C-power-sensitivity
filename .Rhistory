family = binomial)
}
sigma_curve_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + curve_uncert, data = singles_data,
family = binomial(link = 'logit'))
}
offset_sigma_curve_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + offset_magnitude + curve_uncert,
data = singles_data, family = binomial(link = 'logit'))
}
offset_curve_interact_acc68 <- function(singles_data) {
glm(accuracy_68 ~ offset_magnitude + curve_uncert +
offset_magnitude * curve_uncert,
data = singles_data,
family = binomial)
}
sigma_curve_interact_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + curve_uncert +
measurement_error * curve_uncert,
data = singles_data,
family = binomial(link = 'logit'))
}
offset_sigma_curve_interact_sc_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + offset_magnitude + curve_uncert +
measurement_error * curve_uncert,
data = singles_data, family = binomial(link = 'logit'))
}
offset_sigma_curve_interact_oc_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + offset_magnitude + curve_uncert +
offset_magnitude * curve_uncert,
data = singles_data, family = binomial(link = 'logit'))
}
offset_sigma_curve_interact_oc_sc_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + offset_magnitude + curve_uncert +
offset_magnitude * curve_uncert + measurement_error * curve_uncert,
data = singles_data, family = binomial(link = 'logit'))
}
offset_sigma_curve_interact_oc_sc_ocs_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + offset_magnitude + curve_uncert +
offset_magnitude * curve_uncert + measurement_error * curve_uncert +
offset_magnitude * measurement_error * curve_uncert,
data = singles_data, family = binomial(link = 'logit'))
}
offset_sigma_curve_interact_os_acc68 <- function(singles_data) {
glm(accuracy_68 ~ measurement_error + offset_magnitude + curve_uncert +
offset_magnitude * measurement_error,
data = singles_data, family = binomial(link = 'logit'))
}
test0 <- offset_sigma_curve_interact_os_acc68(single_cals_curve_uncert_mod)
test1 <- predict(test0, newdata = logistic_predicts_pos)
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(10, 50), rep(18, 50), rep(26, 50), rep(32, 50)), 4)
)
test1 <- predict(test0, newdata = logistic_predicts_pos)
test0 <- single_cals_curve_uncert_regr$model_results[1]
test0 <- single_cals_curve_uncert_regr$model_results[[1]]
test1 <- predict(test0, newdata = logistic_predicts_pos)
View(single_cals_curve_uncert_regr)
single_cals_curve_uncert_regr$model
## Get the numbers to underpin drawin of curves. Courtesy of Allan Cameron, over here: https://stackoverflow.com/questions/65081329/multiple-logistic-regression-ggplot-with-groups
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(10, 50), rep(18, 50), rep(26, 50), rep(32, 50)), 4)
)
test0 <- offset_sigma_curve_interact_os_acc68(single_cals_curve_uncert_mod)
test0 <- single_cals_curve_uncert_regr$model_results[[1]]
test1 <- predict(test0, newdata = logistic_predicts_pos)
single_cals_curve_uncert_regr$model
single_cals_curve_uncert_regr$is_pos
test1 <- predict(single_cals_curve_uncert_regr$model_results[[27]], newdata = logistic_predicts_pos)
plot(logistic_predicts_pos$offset_magnitude, test1)
test1 <- predict(single_cals_curve_uncert_regr$model_results[[27]],
newdata = logistic_predicts_pos,
type = "response")
plot(logistic_predicts_pos$offset_magnitude, test1)
single_cals_curve_uncert_regr$model
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(10, 50), rep(18, 50), rep(26, 50), rep(32, 50)), 4)
) %>%
mutate(
hpd_68_expect = predict(single_cals_curve_uncert_regr$model_results[[27]],
newdata = logistic_predicts_pos,
type = "response") ,
hpd_95_expect = predict(single_cals_curve_uncert_regr$model_results[[28]],
newdata = logistic_predicts_pos,
type = "response")
)
library(plyr)
library(plyr)
library(tidyverse)
library(broom)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8)
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),
curve_uncert = round_any(curve_uncert, 8)
)
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(10, 50), rep(18, 50), rep(26, 50), rep(32, 50)), 4)
) %>%
mutate(
hpd_68_expect = predict(single_cals_curve_uncert_regr$model_results[[27]],
newdata = logistic_predicts_pos,
type = "response") ,
hpd_95_expect = predict(single_cals_curve_uncert_regr$model_results[[28]],
newdata = logistic_predicts_pos,
type = "response")
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 8) + 2 ## Ditto
)
View(single_cals)
View(single_cals_curve_uncert_mod)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 8) + 2 ## Ditto
) %>%
pull(curve_uncert)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 4) ## Ditto
) %>%
pull(curve_uncert)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 4) ## Ditto
)
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(8, 50), rep(12, 50), rep(16, 50), rep(20, 50)), 4)
) %>%
mutate(
hpd_68_expect = predict(single_cals_curve_uncert_regr$model_results[[27]],
newdata = logistic_predicts_pos,
type = "response") ,
hpd_95_expect = predict(single_cals_curve_uncert_regr$model_results[[28]],
newdata = logistic_predicts_pos,
type = "response")
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
) %>%
filter(measurement_error = 16 & curve_uncert = 12) %>%
```{r}
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
) %>%
filter(measurement_error == 16 & curve_uncert == 12) %>%
ggplot(aes(x = offset_magnitude, y = ratio_accurate_68)) +
geom_bar(stat = "identity")
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 4) ## Ditto
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
)
library(tidyverse)
library(broom)
### Now load up the model data again, nest it and build the model functions
single_cals_curve_uncert_mod <- read_csv("single_cals_curve_uncert_mod.csv")
single_cals_curve_uncert_regr <- readRDS("single_cals_curve_uncert_regr.rds")
## Get the numbers to underpin drawin of curves. Courtesy of Allan Cameron, over here: https://stackoverflow.com/questions/65081329/multiple-logistic-regression-ggplot-with-groups
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(8, 50), rep(12, 50), rep(16, 50), rep(20, 50)), 4)
) %>%
mutate(
hpd_68_expect = predict(single_cals_curve_uncert_regr$model_results[[27]],
newdata = logistic_predicts_pos,
type = "response") ,
hpd_95_expect = predict(single_cals_curve_uncert_regr$model_results[[28]],
newdata = logistic_predicts_pos,
type = "response")
)
## Get the numbers to underpin drawin of curves. Courtesy of Allan Cameron, over here: https://stackoverflow.com/questions/65081329/multiple-logistic-regression-ggplot-with-groups
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(8, 50), rep(12, 50), rep(16, 50), rep(20, 50)), 4)
)
logistic_predicts_pos <- logistic_predicts_pos %>%
mutate(
hpd_68_expect = predict(single_cals_curve_uncert_regr$model_results[[27]],
newdata = logistic_predicts_pos,
type = "response") ,
hpd_95_expect = predict(single_cals_curve_uncert_regr$model_results[[28]],
newdata = logistic_predicts_pos,
type = "response")
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = plyr::round(offset_magnitude, 0),
measurement_error = plyr::round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = plyr::round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = plyr::round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = plyr::round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round(offset_magnitude, 0),
measurement_error = plyr::round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = plyr::round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
) %>%
filter(measurement_error == 16 & curve_uncert == 12) %>%
ggplot(aes(x = offset_magnitude, y = ratio_accurate_68)) +
geom_bar(stat = "identity")
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = round_any(offset_magnitude, 5),
measurement_error = plyr::round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = plyr::round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
) %>%
filter(measurement_error == 16 & curve_uncert == 12) %>%
ggplot(aes(x = offset_magnitude, y = ratio_accurate_68)) +
geom_bar(stat = "identity")
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = plyr::round_any(offset_magnitude, 5),
measurement_error = plyr::round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = plyr::round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
) %>%
filter(measurement_error == 16 & curve_uncert == 12) %>%
ggplot(aes(x = offset_magnitude, y = ratio_accurate_68)) +
geom_bar(stat = "identity")
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(8, 50), rep(12, 50), rep(16, 50), rep(20, 50)), 4)
)
logistic_predicts_pos <- logistic_predicts_pos %>%
mutate(
ratio_accurate_68 = predict(single_cals_curve_uncert_regr$model_results[[27]],
newdata = logistic_predicts_pos,
type = "response") ,
hpd_95_expect = predict(single_cals_curve_uncert_regr$model_results[[28]],
newdata = logistic_predicts_pos,
type = "response")
)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = plyr::round_any(offset_magnitude, 5),
measurement_error = plyr::round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = plyr::round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
) %>%
filter(measurement_error == 16 & curve_uncert == 12) %>%
ggplot(aes(x = offset_magnitude, y = ratio_accurate_68)) +
geom_bar(stat = "identity") +
geom_line(data = logistic_predicts_pos)
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(8, 50), rep(12, 50), rep(16, 50), rep(20, 50)), 4)
)
logistic_predicts_pos <- logistic_predicts_pos %>%
mutate(
ratio_accurate_68 = predict(single_cals_curve_uncert_regr$model_results[[27]],
newdata = logistic_predicts_pos,
type = "response") ,
hpd_95_expect = predict(single_cals_curve_uncert_regr$model_results[[28]],
newdata = logistic_predicts_pos,
type = "response")
) %>%
filter(measurement_error == 16 & curve_uncert == 12)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = plyr::round_any(offset_magnitude, 5),
measurement_error = plyr::round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = plyr::round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
) %>%
filter(measurement_error == 16 & curve_uncert == 12) %>%
ggplot(aes(x = offset_magnitude, y = ratio_accurate_68)) +
geom_bar(stat = "identity") +
geom_line(data = logistic_predicts_pos)
## Get the numbers to underpin drawin of curves. Courtesy of Allan Cameron, over here: https://stackoverflow.com/questions/65081329/multiple-logistic-regression-ggplot-with-groups
logistic_predicts_pos <- data.frame(
offset_magnitude = rep(seq(0, 50, length.out = 50), 16),
measurement_error = c(rep(8, 200), rep(16, 200), rep(24, 200), rep(32, 200)),
curve_uncert = rep(c(rep(8, 50), rep(12, 50), rep(16, 50), rep(20, 50)), 4)
)
logistic_predicts_pos <- logistic_predicts_pos %>%
mutate(
ratio_accurate_68 = predict(single_cals_curve_uncert_regr$model_results[[27]],
newdata = logistic_predicts_pos,
type = "response") ,
hpd_95_expect = predict(single_cals_curve_uncert_regr$model_results[[28]],
newdata = logistic_predicts_pos,
type = "response")
) %>%
filter(measurement_error == 24 & curve_uncert == 12)
single_cals_curve_uncert_mod %>%
filter(offset_magnitude > 0) %>%
mutate(
offset_magnitude = plyr::round_any(offset_magnitude, 5),
measurement_error = plyr::round_any(measurement_error, 8),  ##These will not be exact, but hopefully good enough for visualization
curve_uncert = plyr::round_any(curve_uncert, 4) ## Ditto
) %>%
group_by(offset_magnitude, measurement_error, curve_uncert) %>%
summarize(
ratio_accurate_68 = mean(accuracy_68),
ratio_accurate_95 = mean(accuracy_95)
) %>%
filter(measurement_error == 24 & curve_uncert == 12) %>%
ggplot(aes(x = offset_magnitude, y = ratio_accurate_68)) +
geom_bar(stat = "identity") +
geom_line(data = logistic_predicts_pos)
library(tidyverse)
library(broom)
### Load the data
single_cals <- read_csv("simulation_results/singles_011_results.csv")
single_cals_curve_uncert_regr <- readRDS("single_cals_curve_uncert_regr.rds")
set_up_predicts_tab <- function(param_to_predict = "offset", offset, sigma, curve_uncert) {
## This function takes on information on what parameter we want to predict on and what values to fix for other parameters
## Returns a table of predicted values
## Assumes correct vparameter names entered ("offset", "sigma", "curve_uncert"). Assumes input for values comes either as vectors of min/max, or as desired mean values.
if (param_to_predict == "offset") {
offset_magnitude = seq(offset[1], offset[2], length.out = 100)
measurement_error = rep(mean(sigma), 100)
curve_uncert = rep(mean(curve_uncert), 100)
} else if (param_to_predict == "sigma") {
offset_magnitude = rep(mean(offset_magnitude), 100)
measurement_error = seq(sigma[1], sigma[2], length.out = 100)
curve_uncert = rep(mean(curve_uncert), 100)
} else if (param_to_predict == "curve_uncert") {
offset_magnitude = rep(mean(offset_magnitude), 100)
measurement_error = rep(mean(sigma), 100)
curve_uncert = seq(curve_uncert[1], curve_uncert[2], length.out = 100)
} else {
return(warning("incorrect parmaeter name, please check"))
}
predict_table <- data.frame(offset_magnitude, measurement_error, curve_uncert)
predict_table
}
## Test
set_up_predicts_tab(offset = c(0, 25), sigma = c(8, 32), curve_uncert = c(10, 20))
set_up_predicts_tab(param_to_predict = "sigma", offset = c(0, 25),
sigma = c(8, 32), curve_uncert = c(10, 20))
## Test
set_up_predicts_tab(offset = c(0, 25), sigma = c(8, 32), curve_uncert = c(10, 20))
set_up_predicts_tab(param_to_predict = "sigma", offset = c(0, 25),
sigma = c(8, 32), curve_uncert = c(10, 20))
## Test
set_up_predicts_tab(offset = c(0, 25), sigma = c(8, 32), curve_uncert = c(10, 20))
set_up_predicts_tab(param_to_predict = "sigma", offset = c(0, 25),
sigma = c(8, 32), curve_uncert = c(10, 20))
set_up_predicts_tab <- function(param_to_predict = "offset", offset, sigma, curve_uncert) {
## This function takes on information on what parameter we want to predict on and what values to fix for other parameters
## Returns a table of predicted values
## Assumes correct vparameter names entered ("offset", "sigma", "curve_uncert"). Assumes input for values comes either as vectors of min/max, or as desired mean values.
if (param_to_predict == "offset") {
offset_magnitude = seq(offset[1], offset[2], length.out = 100)
measurement_error = rep(mean(sigma), 100)
curve_uncert = rep(mean(curve_uncert), 100)
} else if (param_to_predict == "sigma") {
offset_magnitude = rep(mean(offset), 100)
measurement_error = seq(sigma[1], sigma[2], length.out = 100)
curve_uncert = rep(mean(curve_uncert), 100)
} else if (param_to_predict == "curve_uncert") {
offset_magnitude = rep(mean(offset), 100)
measurement_error = rep(mean(sigma), 100)
curve_uncert = seq(curve_uncert[1], curve_uncert[2], length.out = 100)
} else {
return(warning("incorrect parmaeter name, please check"))
}
predict_table <- data.frame(offset_magnitude, measurement_error, curve_uncert)
predict_table
}
## Test
set_up_predicts_tab(offset = c(0, 25), sigma = c(8, 32), curve_uncert = c(10, 20))
set_up_predicts_tab(param_to_predict = "sigma", offset = c(0, 25),
sigma = c(8, 32), curve_uncert = c(10, 20))
set_up_predicts_tab(param_to_predict = "curve_uncert", offset = c(0, 25),
sigma = c(8, 32), curve_uncert = c(10, 20))
set_up_predicts_tab(param_to_predict = "potato", offset = c(0, 25),
sigma = c(8, 32), curve_uncert = c(10, 20))
