nest()
###Test the STAN functions
test_df <- single_cals_w_curve_uncert %>%
filter(offset_magnitude > 0)
test_result <- stan_glm(accuracy_95 ~ offset_magnitude + sigma_curve_uncert,
data = test_df, family = binomial(link = 'logit'))
summary(test_result)
single_cals_curve_for_stan <- single_cals_w_curve_uncert %>%
pivot_longer(c(accuracy_68, accuracy_95))
View(single_cals_curve_for_stan)
single_cals_curve_for_stan <- single_cals_w_curve_uncert %>%
pivot_longer(c(accuracy_68, accuracy_95),
names_to = "hpd_area", values_to = "accuracy") %>%
select(curve_uncert, measurement_error, offset_magnitude,
hpd_area, accuracy) %>%
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
single_cals_curve_for_stan <- single_cals_w_curve_uncert %>%
pivot_longer(c(accuracy_68, accuracy_95),
names_to = "hpd_area", values_to = "accuracy") %>%
select(curve_uncert, measurement_error, offset_magnitude,
hpd_area, accuracy) %>%
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "68") & is_pos)
###Test the STAN functions
stan_results <- list()
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "68") & offset_magnitude > 0)
stan_offset_curve_sigma_comb_68_pos <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_results <- append(stan_results, stan_offset_curve_sigma_comb_68_pos)
###Test the STAN functions - yes an ugly way to do it, but too few to justify setting up a nicer loop.
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "68") & offset_magnitude > 0)
stan_offset_curve_sigma_comb_68_pos <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "95") & offset_magnitude > 0)
stan_offset_curve_sigma_comb_95_pos <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "68") & offset_magnitude < 0)
stan_offset_curve_sigma_comb_68_neg <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_df <- single_cals_curve_for_stan |>
filter(str_detect(hpd_area, "95") & offset_magnitude < 0)
stan_offset_curve_sigma_comb_95_neg <- stan_glm(
accuracy ~ offset_magnitude + sigma_curve_uncert,
data = stan_df, family = binomial(link = 'logit'))
stan_offset_curve_sigma_comb <- list(
stan_offset_curve_sigma_comb_68_pos,
stan_offset_curve_sigma_comb_68_neg,
stan_offset_curve_sigma_comb_95_pos,
stan_offset_curve_sigma_comb_95_neg
)
##Lets not keep re-running the models if we don't need to :)
write_rds(stan_offset_curve_sigma_comb, "stan_offset_curve_sigma_comb.rds")
summary(stan_offset_curve_sigma_comb[[1]])
summary(stan_offset_curve_sigma_comb[[2]]) ##68neg
summary(stan_offset_curve_sigma_comb[[3]]) ##95pos
summary(stan_offset_curve_sigma_comb[[4]]) ##95neg
help("summary.stanreg")
installed.packages("bayesplot")
instal.packages("bayesplot")
install.packages("bayesplot")
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
##Lets not keep re-running the models if we don't need to :)
write_rds(stan_offset_curve_sigma_comb, "stan_offset_curve_sigma_comb.rds")
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterios_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
dim(posterios_68_pos)
dimnames(posterios_68_pos)
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
color_scheme_set("blue")
mcmc_hist(posterior_68_pos, pars = c("offset_magnitude", "(Intercept)",
"sigma_curve_uncert"))
color_scheme_set("blue")
mcmc_hist(posterior_68_pos, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
mcmc_hist(posterior_68_neg, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
color_scheme_set("blue")
mcmc_hist(posterior_68_pos, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
mcmc_hist(posterior_68_neg, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
mcmc_hist(posterior_95_pos, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
mcmc_hist(posterior_95_neg, pars = c("(Intercept)", "offset_magnitude",
"sigma_curve_uncert"))
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
mcmc_parcoord(posterior_68_neg)
mcmc_parcoord(posterior_68_neg)
mcmc_parcoord(posterior_68_pos)
mcmc_parcoord(posterior_95_neg)
mcmc_parcoord(posterior_95_pos)
mcmc_pairs(posterior_68_pos)
mcmc_pairs(posterior_68_pos)
mcmc_pairs(posterior_68_neg)
mcmc_pairs(posterior_95_pos)
mcmc_pairs(posterior_95_neg)
mcmc_trace(posterior_68_pos)
mcmc_trace(posterior_68_neg)
mcmc_trace(posterior_95_pos)
mcmc_trace(posterior_95_neg)
mcmc_rhat(posterior_68_pos)
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
dimnames(posterior_68_pos)
dimnames(posterior_68_pos[1])
dimnames(posterior_68_pos[[1]])
coef(posterior_68_pos)[1]
posterior_68_pos[1]
posterior_68_pos[1:1000]
posterior_68_pos[1:1000, 1:4, 1]
posterior_68_pos[1:1000, 1, 1:3]
posterior_68_pos[1:1000, 1, 1]
offset_effects <- posterior_68_pos[1:1000, 1, 2]
offset_effects <- posterior_68_pos[1:1000, 1, 2]
intercepts <- posterior_68_pos[1:1000, 1, 1]
uncert_effects <- posterior_68_pos[1:1000, 1, 3]
pred_results <- intercepts + 20 * offset_effects + 20 * uncert_effects
exp_term <- intercepts + 20 * offset_effects + 20 * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
hist(pred_results)
exists("potato")
exists(stan_offset_curve_sigma_comb)
exists("stan_offset_curve_sigma_comb")
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir = "pos" & hpd_area = "68") {
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
model
}
predict_singles_accuracy("pos", "68")
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
intercepts
}
predict_singles_accuracy("pos", "68")
predict_singles_accuracy("pos", "95")
predict_singles_accuracy("neg", "95")
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
exp_term <- intercepts +
offset_magnitude * offset_effects +
sigma_curve_uncert * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
}
predict_singles_accuracy("neg", "95", 0, 40)
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma_curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
exp_term <- intercepts +
offset_magnitude * offset_effects +
sigma_curve_uncert * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
pred_results
}
predict_singles_accuracy("neg", "95", 0, 40)
predict_singles_accuracy("neg", "95", -40, 40)
predict_singles_accuracy("neg", "95", -40, 10)
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma, curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
## Get the chain results out
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
##Do the maths
sigma_curve_uncert <- sqrt((sigma ^ 2) + (curve_uncert ^ 2))
exp_term <- intercepts +
offset_magnitude * offset_effects +
sigma_curve_uncert * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
pred_results
}
predict_singles_accuracy("neg", "95", -40, 10, 30)
predict_singles_accuracy("pos", "68", 40, 10, 30)
predict_singles_accuracy("neg", "68", -40, 10, 30)
predict_singles_accuracy("pos", "95", 40, 10, 30)
predict_singles_accuracy("neg", "95", -40, 10, 30)
library(rintcal)
install.packages("rintcal")
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
library(rintcal)
calibrate(2450, 50)
caldist(2450, 50)
calBP.14C(2450, 50)
caldist(2450, 50)
install.packages("Bcron")
install.packages("Bchron")
library(Bchron)
BchronCalibrate(2450, 50)
calibrate()
caldist()
caldist(2450, 50)
test <- caldist(2450, 50)
calibrate(2450, 50)
### 10000 Single calibration simulated around the mean of the calibration curve
cal_curve = read_csv("intcal_20_interpolated.csv")
n_sims <- 10000 ### Choose how many sims you want. Start with 10000
target_years <- sample(cal_curve$CalBP, n_sims, replace = T) ### Select some target years
offset_magnitudes <- runif(n_sims, -50, 50) ### Sim offsets
measurement_errors <- runif(n_sims, 8, 35) ### Sim accuracy
offset_14c_ages <- c() ### Empty input folder
### Do the Simulated values vector
for (i in 1:n_sims) {
offset_14c_ages <- c(offset_14c_ages,
rnorm(1, mean = subset(cal_curve, cal_curve$CalBP ==
target_years[i]
)$BP + offset_magnitudes[i],
measurement_errors[i]))
}
list_of_sims <- read_csv("sims_list.csv")
list_of_sims
Singles014Params <- data.frame(TargetYears, Offset14CAges, MeasurementErrors, OffsetMagnitudes)
Singles014Params <- data.frame(target_years,  offset_14c_ages,
measurement_errors, offset_magnitudes)
write.csv(Singles014Params, "Singles014Params.csv")
singles_014_params <- data.frame(target_years,  offset_14c_ages,
measurement_errors, offset_magnitudes)
write.csv(singles_014_params, "singles_014_params.csv")
commands <- c("Plot(){R_Date(", rep("R_Date(", n_sims - 1))
close_singles <- c(rep(");", n_sims - 1), "};};")
commas <- c(rep(",", n_sims))
OxCalInput <- data.frame(commands, singles_014_params$offset_14c_ages, commas,
singles_014_params$offset_14c_ages, close_singles)
names(OxCalInput) <- NULL
rownames(OxCalInput) <- NULL
oxcal_input <- data.frame(commands, singles_014_params$offset_14c_ages, commas,
singles_014_params$offset_14c_ages, close_singles)
names(oxcal_input) <- NULL
rownames(oxcal_input) <- NULL
singles_014_input_names <- c()
for (i in 1:5) {
singles_014_input_names <- c(singles_014_input_names,
paste("/home/pete/Documents/oxcal_results/sensitivity_014_singles", i, ".oxcal", sep = ""))
}
write.table(oxcal_input[1:2000, ], file = singles_014_input_names[1], row.names = F, quote = F)
singles_014_input_names <- c()
for (i in 1:5) {
singles_014_input_names <- c(singles_014_input_names,
paste("/home/pete/Documents/oxcal_results/sensitivity_014_singles/sensitivity_014_singles", i, ".oxcal", sep = ""))
}
write.table(oxcal_input[1:2000, ], file = singles_014_input_names[1], row.names = F, quote = F)
system(paste("/home/pete/OxCal/bin/OxCalLinux",
singles_014_input_names[1]))
oxcal_input <- data.frame(commands, singles_014_params$offset_14c_ages, commas,
singles_014_params$measurement_errors, close_singles)
names(oxcal_input) <- NULL
rownames(oxcal_input) <- NULL
singles_014_input_names <- c()
for (i in 1:5) {
singles_014_input_names <- c(singles_014_input_names,
paste("/home/pete/Documents/oxcal_results/sensitivity_014_singles/sensitivity_014_singles", i, ".oxcal", sep = ""))
}
write.table(oxcal_input[1:2000, ], file = singles_014_input_names[1], row.names = F, quote = F)
system(paste("/home/pete/OxCal/bin/OxCalLinux",
singles_014_input_names[1]))
system(paste("/home/pete/OxCal/bin/OxCalLinux",
singles_014_input_names[1]))
write.table(oxcal_input, file = singles_014_input_names[1], row.names = F, quote = F)
system(paste("/home/pete/OxCal/bin/OxCalLinux",
singles_014_input_names[1]))
simulate_oxcal <- function (target_date, offset_magnitude, measurement_error){
## The function takes on a target date, an offset magnitude and a measurement error
## Returns a simulated OxCal result and ensures simulation folder is clean after running
execute_simulation(target_date, offset_magnitue, measurement_error)
simulation_result <- parse_single()
clean_simulation_folder()
simulation_result
}
simulate_oxcal(target_date = 2450, offset_magnitude = 20, measurement_error = 20)
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
library(Bchron)
intcal20_interpolated <- read_csv("intcal20_interpolated.csv")
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists(intcal20_interpolated)) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date)
age_uncal
}
execute_simulation(target_date = 1)
exists(intcal20_interpolated)
exists(intcal20_interpolated)
exists("intcal20_interpolated")
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date)
age_uncal
}
execute_simulation(target_date = 1)
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date) |>
select(BP) |>
pull()
age_uncal
}
execute_simulation(target_date = 1)
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date) |>
select(BP) |>
pull()
age_uncal <- age_uncal + offset_magntidue
age_uncal
}
execute_simulation(target_date = 500, 20)
execute_simulation(500, 20)
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date) |>
select(BP) |>
pull()
age_uncal <- age_uncal + offset_magnitude
age_uncal
}
execute_simulation(500, 20)
View(intcal20_interpolated)
get_uncal <- function (target_date, offset_magnitude,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a calibration curve
## The function returns a 14C age for the given target date, offset by a given value
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date) |>
select(BP) |>
pull()
age_uncal <- age_uncal + offset_magnitude
age_uncal
}
get_uncal(500, 20)
