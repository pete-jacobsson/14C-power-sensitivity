model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
## Get the chain results out
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
##Do the maths
sigma_curve_uncert <- sqrt((sigma ^ 2) + (curve_uncert ^ 2))
exp_term <- intercepts +
offset_magnitude * offset_effects +
sigma_curve_uncert * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
pred_results
}
predict_singles_accuracy("neg", "95", -40, 10, 30)
predict_singles_accuracy("pos", "68", 40, 10, 30)
predict_singles_accuracy("neg", "68", -40, 10, 30)
predict_singles_accuracy("pos", "95", 40, 10, 30)
predict_singles_accuracy("neg", "95", -40, 10, 30)
library(rintcal)
install.packages("rintcal")
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
library(rintcal)
calibrate(2450, 50)
caldist(2450, 50)
calBP.14C(2450, 50)
caldist(2450, 50)
install.packages("Bcron")
install.packages("Bchron")
library(Bchron)
BchronCalibrate(2450, 50)
calibrate()
caldist()
caldist(2450, 50)
test <- caldist(2450, 50)
calibrate(2450, 50)
### 10000 Single calibration simulated around the mean of the calibration curve
cal_curve = read_csv("intcal_20_interpolated.csv")
n_sims <- 10000 ### Choose how many sims you want. Start with 10000
target_years <- sample(cal_curve$CalBP, n_sims, replace = T) ### Select some target years
offset_magnitudes <- runif(n_sims, -50, 50) ### Sim offsets
measurement_errors <- runif(n_sims, 8, 35) ### Sim accuracy
offset_14c_ages <- c() ### Empty input folder
### Do the Simulated values vector
for (i in 1:n_sims) {
offset_14c_ages <- c(offset_14c_ages,
rnorm(1, mean = subset(cal_curve, cal_curve$CalBP ==
target_years[i]
)$BP + offset_magnitudes[i],
measurement_errors[i]))
}
list_of_sims <- read_csv("sims_list.csv")
list_of_sims
Singles014Params <- data.frame(TargetYears, Offset14CAges, MeasurementErrors, OffsetMagnitudes)
Singles014Params <- data.frame(target_years,  offset_14c_ages,
measurement_errors, offset_magnitudes)
write.csv(Singles014Params, "Singles014Params.csv")
singles_014_params <- data.frame(target_years,  offset_14c_ages,
measurement_errors, offset_magnitudes)
write.csv(singles_014_params, "singles_014_params.csv")
commands <- c("Plot(){R_Date(", rep("R_Date(", n_sims - 1))
close_singles <- c(rep(");", n_sims - 1), "};};")
commas <- c(rep(",", n_sims))
OxCalInput <- data.frame(commands, singles_014_params$offset_14c_ages, commas,
singles_014_params$offset_14c_ages, close_singles)
names(OxCalInput) <- NULL
rownames(OxCalInput) <- NULL
oxcal_input <- data.frame(commands, singles_014_params$offset_14c_ages, commas,
singles_014_params$offset_14c_ages, close_singles)
names(oxcal_input) <- NULL
rownames(oxcal_input) <- NULL
singles_014_input_names <- c()
for (i in 1:5) {
singles_014_input_names <- c(singles_014_input_names,
paste("/home/pete/Documents/oxcal_results/sensitivity_014_singles", i, ".oxcal", sep = ""))
}
write.table(oxcal_input[1:2000, ], file = singles_014_input_names[1], row.names = F, quote = F)
singles_014_input_names <- c()
for (i in 1:5) {
singles_014_input_names <- c(singles_014_input_names,
paste("/home/pete/Documents/oxcal_results/sensitivity_014_singles/sensitivity_014_singles", i, ".oxcal", sep = ""))
}
write.table(oxcal_input[1:2000, ], file = singles_014_input_names[1], row.names = F, quote = F)
system(paste("/home/pete/OxCal/bin/OxCalLinux",
singles_014_input_names[1]))
oxcal_input <- data.frame(commands, singles_014_params$offset_14c_ages, commas,
singles_014_params$measurement_errors, close_singles)
names(oxcal_input) <- NULL
rownames(oxcal_input) <- NULL
singles_014_input_names <- c()
for (i in 1:5) {
singles_014_input_names <- c(singles_014_input_names,
paste("/home/pete/Documents/oxcal_results/sensitivity_014_singles/sensitivity_014_singles", i, ".oxcal", sep = ""))
}
write.table(oxcal_input[1:2000, ], file = singles_014_input_names[1], row.names = F, quote = F)
system(paste("/home/pete/OxCal/bin/OxCalLinux",
singles_014_input_names[1]))
system(paste("/home/pete/OxCal/bin/OxCalLinux",
singles_014_input_names[1]))
write.table(oxcal_input, file = singles_014_input_names[1], row.names = F, quote = F)
system(paste("/home/pete/OxCal/bin/OxCalLinux",
singles_014_input_names[1]))
simulate_oxcal <- function (target_date, offset_magnitude, measurement_error){
## The function takes on a target date, an offset magnitude and a measurement error
## Returns a simulated OxCal result and ensures simulation folder is clean after running
execute_simulation(target_date, offset_magnitue, measurement_error)
simulation_result <- parse_single()
clean_simulation_folder()
simulation_result
}
simulate_oxcal(target_date = 2450, offset_magnitude = 20, measurement_error = 20)
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
library(Bchron)
intcal20_interpolated <- read_csv("intcal20_interpolated.csv")
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists(intcal20_interpolated)) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date)
age_uncal
}
execute_simulation(target_date = 1)
exists(intcal20_interpolated)
exists(intcal20_interpolated)
exists("intcal20_interpolated")
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date)
age_uncal
}
execute_simulation(target_date = 1)
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date) |>
select(BP) |>
pull()
age_uncal
}
execute_simulation(target_date = 1)
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date) |>
select(BP) |>
pull()
age_uncal <- age_uncal + offset_magntidue
age_uncal
}
execute_simulation(target_date = 500, 20)
execute_simulation(500, 20)
execute_simulation <- function (target_date, offset_magnitude,
measurement_error,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a measurement error
## The function combines the inputs into a radiocarbon age and passes those to OxCal
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date) |>
select(BP) |>
pull()
age_uncal <- age_uncal + offset_magnitude
age_uncal
}
execute_simulation(500, 20)
View(intcal20_interpolated)
get_uncal <- function (target_date, offset_magnitude,
curve = "intcal20_interpolated.csv"){
## The function takes on a target date, an offset magnitude and a calibration curve
## The function returns a 14C age for the given target date, offset by a given value
library(readr)
if (!exists("intcal20_interpolated")) {
intcal20_interpolated <- read_csv("intcal_20_interpolated.csv")
}
age_uncal <- intcal20_interpolated |>
filter(CalBP == target_date) |>
select(BP) |>
pull()
age_uncal <- age_uncal + offset_magnitude
age_uncal
}
get_uncal(500, 20)
### The first two items are a later addition if further models need added
### Now load up the model data again, nest it and build the model functions
single_cals_w_curve_uncert <- read_csv("single_cals_w_curve_uncert.csv") %>%
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
library(tidyverse)
library(broom)
library(jtools)
library(rstan)
library(rstanarm)
library(bayesplot)
library(Bchron)
single_cals_curve_uncert_regr <- readRDS("single_cals_curve_uncert_regr.rds")
### Extract the diagnostics
single_cals_curve_uncert_diag <- single_cals_curve_uncert_regr %>%
mutate(model_diags = map(model_results, glance)) %>%
select(-model_results) %>%
unnest(cols = c(model_diags))
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
model_name = "comb_inter",
variable = "offset_magnitude",
range = c(0, 50), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs <- function(offset_dir, hpd_area, model_name, variable,
range, rounding, xlab) {
## This function wraps predict_model_results and plot_simulation_results and plots prediction over simulation.
## parameters and assumptions as per underpinning functions.
plot <- plot_simulation_results_osc(range_to_plot = range, hpd_area = hpd_area,
variable = variable, rounding = rounding,
xlab = xlab)
hpd_for_predict = str_extract(hpd_area, "\\d{2}") ## predict_model_results only takes two-digit numbers as input here (for filtering) - this extracts from HPD area above
predicts_tab <- predict_model_results_osc(offset_dir = offset_dir,
hpd_area = hpd_for_predict,
model_name = model_name,
variable = variable,
variable_range = seq(range[1],
range[2]))
predicts_tab <- predicts_tab %>%
rename("variable_to_plot" = variable, ratio_accurate = 1) ##Dovetail the variable names for the plot at the iteration where interactions start getting explored
plot <- plot +
geom_line(data = predicts_tab)
plot
}
predict_model_results_osc <- function(offset_dir, hpd_area, model_name,
variable, variable_range) {
##Function to simplify prediction generation
##Takes on offset_dir and hpd_area, which simplify the results table,
##Takes on variable name as string and variable range as a sequence
##Assumes offset dir, hpd_area, and variable name provided are all correct
offset_curve_sigma_os <- readRDS("single_cals_curve_uncert_regr.rds") %>%
filter(str_detect(model, model_name)) %>%
mutate(is_pos = if_else(is_pos, "positive", "negative")) %>% ## Change type for filtering
filter(str_detect(is_pos, offset_dir) & str_detect(model, hpd_area))
predicted_results <- make_predictions(offset_curve_sigma_os$model_results[[1]],
pred = variable,
pred.values = variable_range)
predicted_results
}
#### Oooohhh... it works without modification... Thank you past me!
plot_simulation_results_osc <- function(range_to_plot, hpd_area, variable,
rounding, xlab) {
##This function plots the simulation results for the purposes of the results graphing
single_cals_curve_uncert_mod <- read_csv("single_cals_w_curve_uncert.csv") %>%
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
single_cals_curve_uncert_mod %>%
rename(variable_to_plot = variable, hpd_to_plot = hpd_area) %>%
filter(variable_to_plot >= range_to_plot[1] &
variable_to_plot <= range_to_plot) %>%
mutate(
variable_to_plot = plyr::round_any(variable_to_plot, rounding)
) %>%
select(variable_to_plot, hpd_to_plot) %>%
group_by(variable_to_plot) %>%
summarize(
ratio_accurate = mean(hpd_to_plot)
) %>%
ggplot(aes(x = variable_to_plot, y = ratio_accurate)) +
geom_bar(stat = 'identity', fill = "steelblue") +
theme_bw() +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50", linewidth = 0.5),
text = element_text(family = "Corbel")#,
#axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 9)
) +
labs(
y = "Ratio accurate",
x = xlab
)
}
plot_model_predictions_ocs <- function(offset_dir, hpd_area, model_name, variable,
range, rounding, xlab) {
## This function wraps predict_model_results and plot_simulation_results and plots prediction over simulation.
## parameters and assumptions as per underpinning functions.
plot <- plot_simulation_results_osc(range_to_plot = range, hpd_area = hpd_area,
variable = variable, rounding = rounding,
xlab = xlab)
hpd_for_predict = str_extract(hpd_area, "\\d{2}") ## predict_model_results only takes two-digit numbers as input here (for filtering) - this extracts from HPD area above
predicts_tab <- predict_model_results_osc(offset_dir = offset_dir,
hpd_area = hpd_for_predict,
model_name = model_name,
variable = variable,
variable_range = seq(range[1],
range[2]))
predicts_tab <- predicts_tab %>%
rename("variable_to_plot" = variable, ratio_accurate = 1) ##Dovetail the variable names for the plot at the iteration where interactions start getting explored
plot <- plot +
geom_line(data = predicts_tab)
plot
}
predict_model_results_osc <- function(offset_dir, hpd_area, model_name,
variable, variable_range) {
##Function to simplify prediction generation
##Takes on offset_dir and hpd_area, which simplify the results table,
##Takes on variable name as string and variable range as a sequence
##Assumes offset dir, hpd_area, and variable name provided are all correct
offset_curve_sigma_os <- readRDS("single_cals_curve_uncert_regr.rds") %>%
filter(str_detect(model, model_name)) %>%
mutate(is_pos = if_else(is_pos, "positive", "negative")) %>% ## Change type for filtering
filter(str_detect(is_pos, offset_dir) & str_detect(model, hpd_area))
predicted_results <- make_predictions(offset_curve_sigma_os$model_results[[1]],
pred = variable,
pred.values = variable_range)
predicted_results
}
#### Oooohhh... it works without modification... Thank you past me!
plot_model_predictions_ocs <- function(offset_dir, hpd_area, model_name, variable,
range, rounding, xlab) {
## This function wraps predict_model_results and plot_simulation_results and plots prediction over simulation.
## parameters and assumptions as per underpinning functions.
plot <- plot_simulation_results_osc(range_to_plot = range, hpd_area = hpd_area,
variable = variable, rounding = rounding,
xlab = xlab)
hpd_for_predict = str_extract(hpd_area, "\\d{2}") ## predict_model_results only takes two-digit numbers as input here (for filtering) - this extracts from HPD area above
predicts_tab <- predict_model_results_osc(offset_dir = offset_dir,
hpd_area = hpd_for_predict,
model_name = model_name,
variable = variable,
variable_range = seq(range[1],
range[2]))
predicts_tab <- predicts_tab %>%
rename("variable_to_plot" = variable, ratio_accurate = 1) ##Dovetail the variable names for the plot at the iteration where interactions start getting explored
plot <- plot +
geom_line(data = predicts_tab)
plot
}
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
model_name = "comb_inter",
variable = "offset_magnitude",
range = c(0, 50), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
model_name = "comb_inter",
variable = "offset_magnitude",
range = c(0, 50), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs(offset_dir = "neg", hpd_area = "accuracy_68",
model_name = "comb_inter",
variable = "offset_magnitude",
range = c(-50, 0), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_95",
model_name = "comb_inter",
variable = "offset_magnitude",
range = c(0, 50), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs(offset_dir = "neg", hpd_area = "accuracy_95",
model_name = "comb_inter",
variable = "offset_magnitude",
range = c(-50, 0), rounding = 2.5,
xlab = "Offset magnitude")
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_68",
variable = "sigma_curve_uncert",
model_name = "comb_inter",
range = c(10, 40), rounding = 2,
xlab = "Measurement and curve error")
plot_model_predictions_ocs(offset_dir = "neg", hpd_area = "accuracy_68",
variable = "sigma_curve_uncert",
model_name = "comb_inter",
range = c(10, 40), rounding = 2,
xlab = "Measurement and curve error")
plot_model_predictions_ocs(offset_dir = "pos", hpd_area = "accuracy_95",
variable = "sigma_curve_uncert",
model_name = "comb_inter",
range = c(10, 40), rounding = 2,
xlab = "Measurement and curve error")
plot_model_predictions_ocs(offset_dir = "neg", hpd_area = "accuracy_95",
variable = "sigma_curve_uncert",
model_name = "comb_inter",
range = c(10, 40), rounding = 2,
xlab = "Measurement and curve error")
stan_offset_curve_sigma_comb <- read_rds("stan_offset_curve_sigma_comb.rds")
posterior_68_pos <- as.array(stan_offset_curve_sigma_comb[[1]])
posterior_68_neg <- as.array(stan_offset_curve_sigma_comb[[2]])
posterior_95_pos <- as.array(stan_offset_curve_sigma_comb[[3]])
posterior_95_neg <- as.array(stan_offset_curve_sigma_comb[[4]])
predict_singles_accuracy <- function (offset_dir, hpd_area, offset_magnitude,
sigma, curve_uncert){
## Forgive the if statements - this problem does not require high-power processing after all!
if (!exists("stan_offset_curve_sigma_comb")) {
warning("Load MCMC results please!") ## Every now and again, I build defensive habits :P
}
if (offset_dir == "pos" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[1]])
}
if (offset_dir == "neg" & hpd_area == "68") {
model <- as.array(stan_offset_curve_sigma_comb[[2]])
}
if (offset_dir == "pos" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[3]])
}
if (offset_dir == "neg" & hpd_area == "95") {
model <- as.array(stan_offset_curve_sigma_comb[[4]])
}
## Get the chain results out
intercepts <- model[1:1000, 1, 1]
offset_effects <- model[1:1000, 1, 2]
uncert_effects <- model[1:1000, 1, 3]
##Do the maths
sigma_curve_uncert <- sqrt((sigma ^ 2) + (curve_uncert ^ 2))
exp_term <- intercepts +
offset_magnitude * offset_effects +
sigma_curve_uncert * uncert_effects
pred_results <- 1 / (1 + exp(-exp_term))
pred_results
}
predict_singles_accuracy("pos", "68", 40, 10, 30) |>
median()
##Read and nest the data
single_cals_w_curve_uncert <- read_csv("single_cals_w_curve_uncert.csv")
single_cals_curve_for_stan |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
single_cals_w_curve_uncert |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2)))
single_cals_w_curve_uncert |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2))) %>%
pull(sigma_curve_uncert)
single_cals_w_curve_uncert |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2))) |>
pull(sigma_curve_uncert) |>
median()
single_cals_w_curve_uncert |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2))) |>
pull(sigma_curve_uncert) |>
min()
single_cals_w_curve_uncert |>
mutate(sigma_curve_uncert = sqrt((measurement_error^2) + (curve_uncert^2))) |>
pull(sigma_curve_uncert) |>
max()
single_cals_w_curve_uncert |>
filter(offset_magnitude > 0) |>
pull(offset_magnitude) |>
median()
prep_predict_df <- function (param, curves_to_plot, offset_dir, hpd_area,
offset_magnitude, sigma, curve_uncert){
###Takes on information on param of interest, number of plausible curves to plot as well as predict_singles_accuracy inputs.
###Returns a table with results for desired number of plausible curves, as well as the median curve
## First, lets set up the varias
if (str_detect(param, "offset")) {
varia_param <- seq(0, 50, 1)
const_param <- 28 ## Median value of sigma_curve combined
} else {### call me lazy
varia_param <- seq(12, 47, 1)
const_param <- 25 ## Median offset_magnitude
}
list(varia_param, const_param)
##While a vectorized solution is possible, here loopy code will be way easier.
}
predict_singles_accuracy("offset", "pos", "68", 40, 10, 30)
predict_singles_accuracy("offset")
prep_predict_df <- function (param, curves_to_plot, offset_dir, hpd_area,
offset_magnitude, sigma, curve_uncert){
###Takes on information on param of interest, number of plausible curves to plot as well as predict_singles_accuracy inputs.
###Returns a table with results for desired number of plausible curves, as well as the median curve
## First, lets set up the varias
if (str_detect(param, "offset")) {
varia_param <- seq(0, 50, 1)
const_param <- 28 ## Median value of sigma_curve combined
} else {### call me lazy
varia_param <- seq(12, 47, 1)
const_param <- 25 ## Median offset_magnitude
}
list(varia_param, const_param)
##While a vectorized solution is possible, here loopy code will be way easier.
}
prep_predict_df("offset")
prep_predict_df("zonk")
